<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Le Labo Packaging Generator — Particle Text (static)</title>
<style>
    :root { --card-w: 280px; --card-h: 260px; }

    body{
        font-family: Arial, sans-serif;
        background: #f6f6f6;
        padding: 40px;
        margin: 0;
        box-sizing: border-box;
    }

    #gridContainer{
        display:grid;
        grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
        gap: 40px;
        width: 100%;
    }

    .labelCard{
        background: white;
        padding: 20px;
        border-radius: 20px;
        height: var(--card-h);
        display:flex;
        justify-content:center;
        align-items:center;
        position:relative;
        overflow:hidden;
    }

    .particleCanvas {
        position:absolute;
        top:0;
        left:0;
        width:100%;
        height:100%;
        z-index:0;
        pointer-events:none;
        image-rendering: optimizeQuality;
    }

    .labelPreview {
        z-index:2;
        position:relative;
        font-size:18px;
        color:transparent;
    }

    @font-face { font-family: 'spicy'; src: url('spicy.otf'); font-display: swap; }
    @font-face { font-family: 'woody'; src: url('woody.ttf'); font-display: swap; }
    @font-face { font-family: 'floral'; src: url('floral.ttf'); font-display: swap; }
    @font-face { font-family: 'aquatic'; src: url('aquatic.otf'); font-display: swap; }

    .sr-only { position: absolute; left:-9999px; top:auto; width:1px; height:1px; overflow:hidden; }
</style>
</head>
<body>

<div id="gridContainer" aria-live="polite"></div>

<script>
(async function init(){
    const sheetID = "1nmLZXO_OKk52Ya06ONY0IHi9RzWURj8E8sQcrC30PcI";
    const tabName = "Sheet1";
    const opensheet_uri = `https://opensheet.elk.sh/${sheetID}/${tabName}`;

    const graffitiFonts = {
        Floral: "floral",
        Woody: "woody",
        Spicy: "spicy",
        Aquatic: "aquatic"
    };

    const timeColors = {
    morning: "morningGradient",
    afternoon: "afternoonGradient",
    evening: "eveningGradient"
    };


    const fontsToLoad = Object.values(graffitiFonts).map(f => `${400} 24px "${f}"`);
    try {
        await document.fonts.ready;
        await Promise.all(fontsToLoad.map(desc => document.fonts.load(desc)));
        await new Promise(r => setTimeout(r, 50));
        console.log("Custom fonts loaded");
    } catch(e){
        console.warn("Fonts may not be fully loaded:", e);
    }

    let perfumeDB = [];
    try {
        const res = await fetch(opensheet_uri);
        const rows = await res.json();
        perfumeDB = rows.map(r => ({
            name: String(r.name || "").trim(),
            scent: String(r.scent || "").trim(),
            intensity: Number(r.intensity) || 6,
            time: String(r.time || "").trim().toLowerCase()
        }));
    } catch(err){
        console.error("Sheet loading error:", err);
        perfumeDB = [
            { name:"SANTAL 33", scent:"Woody", intensity:9, time:"evening" },
            { name:"BERGAMOTE 22", scent:"Floral", intensity:7, time:"morning" }
        ];
    }

    const container = document.getElementById("gridContainer");
    container.innerHTML = "";

    perfumeDB.forEach(perfume => {
        const card = document.createElement("div");
        card.className = "labelCard";

        const canvas = document.createElement("canvas");
        canvas.className = "particleCanvas";
        card.appendChild(canvas);

        const sr = document.createElement("div");
        sr.className = "labelPreview";
        sr.innerText = perfume.name;
        card.appendChild(sr);

        container.appendChild(card);

        sizeCanvasToCardAndDraw(canvas, card, perfume);
    });

    let resizeTimer = null;
    window.addEventListener("resize", () => {
        clearTimeout(resizeTimer);
        resizeTimer = setTimeout(() => {
            document.querySelectorAll(".labelCard").forEach((card, idx) => {
                const canvas = card.querySelector("canvas.particleCanvas");
                const p = perfumeDB[idx];
                if (canvas && p) sizeCanvasToCardAndDraw(canvas, card, p);
            });
        }, 120);
    });

function sizeCanvasToCardAndDraw(canvas, card, perfume){
    const dpr = Math.max(window.devicePixelRatio || 1, 1);
    const rect = card.getBoundingClientRect();
    const cssW = rect.width;
    const cssH = rect.height;

    canvas.style.width = cssW + "px";
    canvas.style.height = cssH + "px";

    canvas.width = Math.round(cssW * dpr);
    canvas.height = Math.round(cssH * dpr);

    const ctx = canvas.getContext("2d");
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

    // ==========================================
    // ⭐ CREATE GRADIENTS
    // ==========================================
    const morningGrad = ctx.createLinearGradient(0, 0, cssW, cssH);
    morningGrad.addColorStop(0, "#FFE066"); // soft yellow
    morningGrad.addColorStop(1, "#FF8C42"); // orange

    // ⭐ AFTERNOON GRADIENT (orange → light blue)
    const afternoonGrad = ctx.createLinearGradient(0, 0, cssW, cssH);
    afternoonGrad.addColorStop(0, "#FF8C42");   // warm orange
    afternoonGrad.addColorStop(1, "#87CEFA");   // light sky blue


    const eveningGrad = ctx.createLinearGradient(0, 0, cssW, cssH);
    eveningGrad.addColorStop(0, "#4A90E2"); // bright blue
    eveningGrad.addColorStop(1, "#0D1B4C"); // deep dark blue

    // ==========================================
    // ⭐ CHOOSE GRADIENT BASED ON PERFUME TIME
    // ==========================================
    let fillStyle = "#222";
    if (perfume.time === "morning") fillStyle = morningGrad;
    if (perfume.time === "afternoon") fillStyle = afternoonGrad;
    if (perfume.time === "evening") fillStyle = eveningGrad;


    drawParticleTextOptimized(
        ctx,
        cssW,
        cssH,
        perfume.name,
        graffitiFonts[perfume.scent] || "Arial",
        fillStyle,       // <-- NOW A GRADIENT
        perfume.intensity
    );
}


    function drawParticleTextOptimized(ctx, cssW, cssH, text, fontFamily, color, intensity){
        ctx.clearRect(0,0,cssW,cssH);

        const SUPERSAMPLE = 3;
        const bw = Math.round(cssW * SUPERSAMPLE);
        const bh = Math.round(cssH * SUPERSAMPLE);
        const buffer = document.createElement("canvas");
        buffer.width = bw;
        buffer.height = bh;
        const bctx = buffer.getContext("2d");

        bctx.clearRect(0,0,bw,bh);

        let testSize = Math.round(bh * 0.5);
        const maxWidth = bw * 0.92;
        bctx.textAlign = "center";
        bctx.textBaseline = "middle";

        while(testSize > 8){
            bctx.font = `${testSize}px "${fontFamily}"`;
            if(bctx.measureText(text).width <= maxWidth) break;
            testSize -= 2;
        }

        bctx.fillStyle = "#000";
        bctx.font = `${testSize}px "${fontFamily}"`;
        bctx.fillText(text, bw/2, bh/2);

        const img = bctx.getImageData(0,0,bw,bh).data;

        // =============================
        // ✅ INTENSITY → PARTICLE SIZE
        // =============================
           // DIRECT INTENSITY LOOKUP — ONLY THIS PART CHANGED
        const intSettings = {
            5:  { radius: 0.6, step: 6 },
            6:  { radius: 0.7, step: 5 },
            7:  { radius: 0.8, step: 5 },
            8:  { radius: 0.9, step: 4 },
            9:  { radius: 1, step: 3 },
            10: { radius: 1.1, step: 3 }
        };

        const clampedIntensity = Math.max(5, Math.min(10, Number(intensity) || 5));
        const particleRadius = intSettings[clampedIntensity].radius;
        const step = intSettings[clampedIntensity].step;
        // =============================

        ctx.fillStyle = color;

        for(let by=0; by<bh; by+=step){
            for(let bx=0; bx<bw; bx+=step){
                const idx = (by * bw + bx) * 4;
                const alpha = img[idx + 3];

                if(alpha > 150){
                    const px = (bx / SUPERSAMPLE);
                    const py = (by / SUPERSAMPLE);

                    const jitter = (Math.random() - 0.5) * 0.3;
                    const r = particleRadius + jitter;

                    ctx.beginPath();
                    ctx.arc(px, py, r, 0, Math.PI*2);
                    ctx.fill();
                }
            }
        }
    }

})();
</script>

</body>
</html>
